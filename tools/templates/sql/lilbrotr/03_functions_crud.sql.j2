{% extends "base/03_functions_crud.sql.j2" %}
{% block header_comment %}
 * LilBrotr - 03_functions_crud.sql
 *
 * CRUD stored functions for bulk data operations. Organized in two levels:
 *
 *   Level 1 (Base) - Single-table operations:
 *     relay_insert, event_insert, metadata_insert,
 *     event_relay_insert, relay_metadata_insert,
 *     service_state_upsert, service_state_get, service_state_delete
 *
 *   Level 2 (Cascade) - Multi-table atomic operations that call Level 1:
 *     event_relay_insert_cascade  -> relay + event + event_relay
 *     relay_metadata_insert_cascade -> relay + metadata + relay_metadata
 *
 * LilBrotr difference: event_insert() accepts the same parameters as
 * BigBrotr for interface compatibility, but stores NULL for tags, content,
 * and sig. Tagvalues is computed at insert time from the incoming tags.
 *
 * Dependencies: 02_tables.sql
{% endblock %}
{% block events_insert_comment %}
 * event_insert(BYTEA[], BYTEA[], BIGINT[], INTEGER[], JSONB[], TEXT[], BYTEA[]) -> INTEGER
 *
 * Bulk-inserts Nostr events in lightweight mode. Accepts the same parameter
 * signature as BigBrotr for interface compatibility, but stores NULL for
 * tags, content, and sig. Tagvalues is computed at insert time from the
 * incoming tags parameter via tags_to_tagvalues().
 *
 * Parameters:
 *   p_event_ids        - Array of 32-byte event hashes
 *   p_pubkeys          - Array of 32-byte author public keys
 *   p_created_ats      - Array of Unix creation timestamps
 *   p_kinds            - Array of NIP-01 event kinds
 *   p_tags             - Array of JSONB tag arrays (used to compute tagvalues, stored as NULL)
 *   p_content_values   - Array of event content strings (accepted but stored as NULL)
 *   p_sigs             - Array of 64-byte Schnorr signatures (accepted but stored as NULL)
 *
 * Returns: Number of newly inserted rows
{% endblock %}
{% block events_insert_params %}
    p_event_ids BYTEA [],
    p_pubkeys BYTEA [],
    p_created_ats BIGINT [],
    p_kinds INTEGER [],
    p_tags JSONB [],           -- Used to compute tagvalues, stored as NULL
    p_content_values TEXT [],  -- Accepted but stored as NULL
    p_sigs BYTEA []            -- Accepted but stored as NULL
{% endblock %}
{% block events_insert_body %}
    -- Store essential fields + compute tagvalues; tags/content/sig remain NULL
    INSERT INTO event (id, pubkey, created_at, kind, tagvalues)
    SELECT id, pubkey, created_at, kind, tags_to_tagvalues(tags)
    FROM unnest(p_event_ids, p_pubkeys, p_created_ats, p_kinds, p_tags)
        AS t(id, pubkey, created_at, kind, tags)
    ON CONFLICT (id) DO NOTHING;
{% endblock %}
{% block events_insert_description %}
'Bulk insert events (lightweight: computes tagvalues, stores NULL for tags/content/sig)';
{% endblock %}
{% block events_relays_insert_cascade %}
/*
 * event_relay_insert_cascade(...) -> INTEGER
 *
 * Atomically inserts relays, events, and their junction records in a single
 * transaction. Delegates to relay_insert() and event_insert() internally,
 * so the lightweight NULL-storage behavior of event_insert() applies here.
 *
 * Parameters: Arrays of event fields + relay fields + seen_at timestamps
 * Returns: Number of junction rows inserted in event_relay
 */
CREATE OR REPLACE FUNCTION event_relay_insert_cascade(
    p_event_ids BYTEA [],
    p_pubkeys BYTEA [],
    p_created_ats BIGINT [],
    p_kinds INTEGER [],
    p_tags JSONB [],           -- Used to compute tagvalues, stored as NULL
    p_content_values TEXT [],  -- Accepted but stored as NULL
    p_sigs BYTEA [],           -- Accepted but stored as NULL
    p_relay_urls TEXT [],
    p_relay_networks TEXT [],
    p_relay_discovered_ats BIGINT [],
    p_seen_ats BIGINT []
)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_row_count INTEGER;
BEGIN
    -- Ensure relay records exist before inserting junction rows
    PERFORM relay_insert(p_relay_urls, p_relay_networks, p_relay_discovered_ats);

    -- Ensure event records exist (lightweight: computes tagvalues, NULL for rest)
    PERFORM event_insert(p_event_ids, p_pubkeys, p_created_ats, p_kinds, p_tags, p_content_values, p_sigs);

    -- Insert junction records, deduplicating within the batch via DISTINCT ON
    INSERT INTO event_relay (event_id, relay_url, seen_at)
    SELECT DISTINCT ON (event_id, relay_url) event_id, relay_url, seen_at
    FROM unnest(p_event_ids, p_relay_urls, p_seen_ats) AS t(event_id, relay_url, seen_at)
    ON CONFLICT (event_id, relay_url) DO NOTHING;

    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    RETURN v_row_count;
END;
$$;

COMMENT ON FUNCTION event_relay_insert_cascade(
    BYTEA [], BYTEA [], BIGINT [], INTEGER [], JSONB [], TEXT [], BYTEA [],
    TEXT [], TEXT [], BIGINT [], BIGINT []
) IS
'Atomically insert events with relays and junctions (lightweight: NULL for tags/content/sig), returns junction row count';
{% endblock %}
{% block service_data_functions %}
-- ==========================================================================
-- SERVICE STATE FUNCTIONS
-- ==========================================================================


/*
 * service_state_upsert(TEXT[], TEXT[], TEXT[], JSONB[], BIGINT[]) -> VOID
 *
 * Bulk upsert (insert or replace) service state records. When a record with
 * the same (service_name, state_type, state_key) already exists, its
 * state_value and timestamp are fully replaced. DISTINCT ON deduplicates
 * within the batch.
 */
CREATE OR REPLACE FUNCTION service_state_upsert(
    p_service_names TEXT [],
    p_state_types TEXT [],
    p_state_keys TEXT [],
    p_state_values JSONB [],
    p_updated_ats BIGINT []
)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO service_state (service_name, state_type, state_key, state_value, updated_at)
    SELECT DISTINCT ON (service_name, state_type, state_key)
        service_name, state_type, state_key, state_value, updated_at
    FROM unnest(
        p_service_names,
        p_state_types,
        p_state_keys,
        p_state_values,
        p_updated_ats
    ) AS t(service_name, state_type, state_key, state_value, updated_at)
    ON CONFLICT (service_name, state_type, state_key)
    DO UPDATE SET
        state_value = EXCLUDED.state_value,
        updated_at = EXCLUDED.updated_at;
END;
$$;

COMMENT ON FUNCTION service_state_upsert(TEXT [], TEXT [], TEXT [], JSONB [], BIGINT []) IS
'Bulk upsert service state with deduplication and full replacement semantics';


/*
 * service_state_get(TEXT, TEXT, TEXT) -> TABLE(state_key, state_value, updated_at)
 *
 * Retrieves service state records. When p_state_key is provided, returns the
 * single matching record. When NULL, returns all records for the given
 * service and state type, ordered by update timestamp ascending.
 */
CREATE OR REPLACE FUNCTION service_state_get(
    p_service_name TEXT,
    p_state_type TEXT,
    p_state_key TEXT DEFAULT NULL
)
RETURNS TABLE (
    state_key TEXT,
    state_value JSONB,
    updated_at BIGINT
)
LANGUAGE plpgsql
AS $$
BEGIN
    IF p_state_key IS NOT NULL THEN
        RETURN QUERY
        SELECT ss.state_key, ss.state_value, ss.updated_at
        FROM service_state ss
        WHERE ss.service_name = p_service_name
          AND ss.state_type = p_state_type
          AND ss.state_key = p_state_key;
    ELSE
        RETURN QUERY
        SELECT ss.state_key, ss.state_value, ss.updated_at
        FROM service_state ss
        WHERE ss.service_name = p_service_name
          AND ss.state_type = p_state_type
        ORDER BY ss.updated_at ASC;
    END IF;
END;
$$;

COMMENT ON FUNCTION service_state_get IS
'Retrieve service state records, optionally filtered by key';


/*
 * service_state_delete(TEXT[], TEXT[], TEXT[]) -> INTEGER
 *
 * Bulk-deletes service state records matching the given composite keys.
 *
 * Returns: Number of rows deleted
 */
CREATE OR REPLACE FUNCTION service_state_delete(
    p_service_names TEXT [],
    p_state_types TEXT [],
    p_state_keys TEXT []
)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_row_count INTEGER;
BEGIN
    DELETE FROM service_state ss
    USING unnest(
        p_service_names,
        p_state_types,
        p_state_keys
    ) AS d(sn, st, sk)
    WHERE ss.service_name = d.sn
      AND ss.state_type = d.st
      AND ss.state_key = d.sk;

    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    RETURN v_row_count;
END;
$$;

COMMENT ON FUNCTION service_state_delete(TEXT [], TEXT [], TEXT []) IS
'Bulk delete service state records, returns number of rows deleted';
{% endblock %}
